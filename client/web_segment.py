import sys
import json
import uuid
# sys.path.insert(0, "C:\\Users\\Laura\\Desktop\\SCA-project-1\\lib")
# import crypto
from lib import crypto
from binascii import hexlify
import rsa


class WebSegment:
    PubKM: any
    PubKPG: str
    CardN: str
    privKM: any
    CardExp: str
    CCode: str
    OrderDesc: str
    # client RSA keys
    PubKC: any
    PrivKC: any
    PubKPG: any
    # AES session symmetric key
    K: any
    Amount: str
    Sig: str
    # State values used for steps 7 & 8
    Sid: str
    NC: str

    def __init__(self, amount) -> None:
        # Preparation Phase
        # The web segment has:
        self.privKM, self.PubKM = crypto.load_rsa_keys("../server/certs")
        privKPG, self.PubKPG = crypto.load_rsa_keys("../server/PG/certs")

        self.Amount = amount

        # requires from C the credit card info
        self.getCreditCard()

        # generates a RSA session public/private key
        crypto.generate_rsa_keys("../client/certs")
        self.PrivKC, self.PubKC = crypto.load_rsa_keys("../client/certs")

        # generate AES session symmetric key
        self.K = crypto.generate_aes_key("../client/certs")

    def getCreditCard(self):
        print("####### PAYMENT #######\n"
              "Please provide your credit card information: ")
        self.CardN = input("Card number: ")
        self.CardExp = input("Expiration date: ")
        self.CCode = input("Challenge code: ")
        self.OrderDesc = input("Order description: ")

    def step1(self) -> str:
        PubKC_K, nonce, tag = crypto.aes_encrypt(self.PubKC.save_pkcs1(),
                                                 self.K)
        K_PubKM = crypto.rsa_encrypt(hexlify(self.K).decode('utf-8'),
                                     self.PubKM)
        return json.dumps({'PubKC_K': hexlify(PubKC_K).decode('utf-8'),
                           'nonce': hexlify(nonce).decode('utf-8'),
                           'tag': hexlify(tag).decode('utf-8'),
                           'K_PubKM': hexlify(K_PubKM).decode('utf-8')})

    def step2(self, data) -> bool:
        # decrypt message
        K = crypto.rsa_decrypt(bytes.fromhex(data['K_PubKC']), self.PrivKC)
        msg_bytes = crypto.aes_decrypt(bytes.fromhex(data['msg_K']),
                                       bytes.fromhex(data['nonce']),
                                       bytes.fromhex(data['tag']),
                                       bytes.fromhex(K))
        msg_data = json.loads(msg_bytes.decode('utf-8'))

        # verify
        if (crypto.rsa_verify(msg_data['Sid'],
                              bytes.fromhex(msg_data['Sig_M']),
                              self.PubKM)):
            self.Sid = msg_data['Sid']
            return True
        else:
            return False

    def step3(self):
        self.NC = uuid.uuid4().hex
        PI = json.dumps({'CardN': self.CardN,
                         'CardExp': self.CardExp,
                         'CCode': self.CCode,
                         'Sid': self.Sid,
                         'Amount': self.Amount,
                         'PubKC': hexlify(self.PubKC.save_pkcs1()).decode('utf-8'),
                         'NC': self.NC,  # fresh nonce generated by C
                         'M': "idk"  # M's identity (idk what it is)
                         })

        SigC_PI = crypto.rsa_sign(PI, self.PrivKC)
        plaintext = json.dumps({'PI': PI, 'SigC_PI': hexlify(SigC_PI).decode('utf-8')})

        # PM = {PI, SigC(PI)}_PubKPG
        PM_K, nonce, tag = crypto.aes_encrypt(plaintext.encode('utf-8'),
                                              self.K)
        K_PubKPG = crypto.rsa_encrypt(hexlify(self.K).decode('utf-8'),
                                      self.PubKPG)
        PM = json.dumps({'PM_K': hexlify(PM_K).decode('utf-8'),
                         'nonce': hexlify(nonce).decode('utf-8'),
                         'tag': hexlify(tag).decode('utf-8'),
                         'K_PubKPG': hexlify(K_PubKPG).decode('utf-8')})

        purchase_order = json.dumps({
            'OrderDesc': self.OrderDesc,
            'Sid': self.Sid,
            'Amount': self.Amount,
            'NC': self.NC
        })
        SigC_PO = crypto.rsa_sign(purchase_order, self.PrivKC)

        PO = json.dumps({
            'purchase_order': purchase_order,
            'SigC_PO': hexlify(SigC_PO).decode('utf-8')
        })

        step3_msg = json.dumps({'PM': PM, 'PO': PO})

        msg_K, nonce, tag = crypto.aes_encrypt(step3_msg.encode('utf-8'),
                                               self.K)
        K_PubKM = crypto.rsa_encrypt(hexlify(self.K).decode('utf-8'),
                                     self.PubKM)
        return json.dumps({'msg_K': hexlify(msg_K).decode('utf-8'),
                           'nonce': hexlify(nonce).decode('utf-8'),
                           'tag': hexlify(tag).decode('utf-8'),
                           'K_PubKM': hexlify(K_PubKM).decode('utf-8')})

    def step6(self, data):
        K = crypto.rsa_decrypt(bytes.fromhex(data["K_PubKC"]), self.PrivKC)
        msg_bytes = crypto.aes_decrypt(bytes.fromhex(data["msg_K"]),
                                       bytes.fromhex(data["nonce"]),
                                       bytes.fromhex(data["tag"]),
                                       bytes.fromhex(K))
        msg = json.loads(json.loads(msg_bytes.decode("utf-8")))  # TODO: should the entire message be decrypted ??
        return bool(msg["Resp"]), msg["Sig_PM"]

    def step7(self):
        # Sid, Amount, NC, PubKC, SigC(Sid, Amount, NC, PubKC)
        msg = json.dumps({
            "Sid": self.Sid,
            "Amount": self.Amount,
            "NC": self.NC,
            "PubKC": hexlify(self.PubKC.save_pkcs1()).decode('utf-8'),
        })
        SigC = crypto.rsa_sign(msg, self.PrivKC)
        step7_msg = json.dumps({
            "Sid": self.Sid,
            "Amount": self.Amount,
            "NC": self.NC,
            "PubKC": hexlify(self.PubKC.save_pkcs1()).decode('utf-8'),
            "SigC": hexlify(SigC).decode("utf-8")
        })
        # encrypt step 7 message
        msg_K, nonce, tag = crypto.aes_encrypt(step7_msg.encode('utf-8'), self.K)
        K_PubKPG = crypto.rsa_encrypt(hexlify(self.K).decode('utf-8'), self.PubKPG)
        coded_msg = {'msg_K': hexlify(msg_K).decode('utf-8'),
                     'nonce': hexlify(nonce).decode('utf-8'),
                     'tag': hexlify(tag).decode('utf-8'),
                     'K_PubKPG': hexlify(K_PubKPG).decode('utf-8')}
        return json.dumps(coded_msg)

    def step8(self, data) -> bool:
        K = crypto.rsa_decrypt(bytes.fromhex(data["K_PubKC"]), self.PrivKC)
        msg_bytes = crypto.aes_decrypt(bytes.fromhex(data["msg_K"]),
                                       bytes.fromhex(data["nonce"]),
                                       bytes.fromhex(data["tag"]),
                                       bytes.fromhex(K))
        msg = json.loads(json.loads(msg_bytes.decode("utf-8")))  # TODO: should the entire message be decrypted ??

        unsigned_msg = {
            "Amount": self.Amount,
            "NC": self.NC,
            "Resp": msg["Resp"],
            "Sid": msg["Sid"],
        }
        verified = crypto.rsa_verify(json.dumps(unsigned_msg), bytes.fromhex(msg["Sig_PG"]), self.PubKPG)

        return bool(msg["Resp"]), verified
